//USING NAIVE or BRUTE FORCE APPROACH

void prime_factorization(long long n)
{
	for(long long i=2; i<=n; i++)
	{
	   if(n%i == 0)
	   {
	      long long count=0;
	      while(n%i == 0)
	      {
	         count++;
	         n/=i;
	      }

	      cout<<i<<"^"<<count<<"\n";
	   }
	}
}

//Time Complexity: O(n)

*********************************************************************************************************************************************************

//OPTIMIZED APPROACH than NAIVE METHOD
/*ğ‘°ğ’‡ ğ’ ğ’Šğ’” ğ’‚ ğ’„ğ’ğ’ğ’‘ğ’ğ’”ğ’Šğ’•ğ’† ğ’ğ’. ğ’•ğ’‰ğ’†ğ’ ğ’•ğ’‰ğ’†ğ’“ğ’† ğ’Šğ’” ğ’‚ğ’• ğ’ğ’†ğ’‚ğ’”ğ’• 1 ğ’‘ğ’“ğ’Šğ’ğ’† ğ’…ğ’Šğ’—ğ’Šğ’”ğ’ğ’“ ğ’ğ’‡ ğ’ ğ’˜ğ’‰ğ’Šğ’„ğ’‰ ğ’Šğ’” ğ’ğ’†ğ’”ğ’” ğ’•ğ’‰ğ’‚ğ’ ğ’ğ’“ ğ’†ğ’’ğ’–ğ’‚ğ’ ğ’•ğ’ ğ’”ğ’’ğ’“ğ’•(ğ’).*/

void prime_factorization(long long n)
{
	for(long long i=2; i*i<=n; i++)
	{
	   if(n%i == 0)
	   {
	      long long count=0;
	      while(n%i == 0) //while i divides n, increment count by 1 and divide n by i  
	      {
             count++;
             n/=i;
	      }

	      cout<<i<<"^"<<count<<"\n";
	   }
	}

	if(n>1) cout<<n<<"^"<<1<<"\n"; //this condition is to handle the case when
	                              //either n was initially a prime no. or
	                             //it has become a prime after coming out of the for loop
}

//Time Complexity: O(sqrt(n))

*********************************************************************************************************************************************************

//USING SIEVE FOR MULTIPLE QUERIES
/**We can calculate the prime factorization of a number â€œnâ€ in O(sqrt(n)) as discussed above. But O(sqrt n) method times out when 
   we need to answer multiple queries regarding prime factorization.

  *Here is the efficient method to calculate the prime factorization using O(n) auxiliary space (by creating a spf_sieve) and 
   O(logâ‚‚n) time complexity with PRECOMPUTATIONS ALLOWED. The precomputation involves forming a spf_sieve with time complexity 
   O(n*logâ‚‚(logâ‚‚n))
   
  *Key Concept used in the algorithm: Main idea is to store the Smallest Prime Factor(spf) for every number in a spf_sieve vector. 
   Then to calculate the prime factorization of the given number by dividing the given number repeatedly with its smallest prime factor till it becomes 1.
*/  

#define max 10000001
vector<int> spf_sieve(max); //spf_sieve[i] stores the smallest prime factor for i 

void sieve_having_min_prime_factor_for_every_no()
{
	spf_sieve[1]=1;
	for(int i=2; i<max; i++)
	{
	   // marking smallest prime factor for every 
       // number to be itself initially 
	   spf_sieve[i]=i;
	}

	for(int i=4; i<max; i+=2)
	{
	   // separately marking spf for every even 
       // number as 2 
	   spf_sieve[i]=2;
	}

	for(int i=3; i*i<=(max-1); i+=2)
	{
	   if(spf_sieve[i]=i) //checking if i is prime or not as only a prime
	                      //no. can be it's own spf
	   {
	      //marking spf for all numbers divisible by i as i 
	      for(int j=i*i; i<=(max-1); j+=i)
	      {
	         if(spf_sieve[j]==j) //marking spf[j] if it is not previously marked  
	           spf_sieve[j]=i;
	      }
	   }
	}
}

//A O(log n) function returning primefactorization of a no. n
//by dividing the no. by it's smallest prime factor at every step 

vector<int> get_prime_factorization(int n)
{
	vector<int> res;
	while(n>1)
	{
	   res.push_back(spf_sieve[n]);
	   n/=spf_sieve[n];
	}

	return res;
}

//Time Complexity: O(logâ‚‚n), worst case.
/*ğ‘µğ’ğ’•ğ’† : ğ‘»ğ’‰ğ’† ğ’‚ğ’ƒğ’ğ’—ğ’† ğ’„ğ’ğ’…ğ’† ğ’˜ğ’ğ’“ğ’Œğ’” ğ’˜ğ’†ğ’ğ’ ğ’‡ğ’ğ’“ ğ’ ğ’–ğ’‘ğ’•ğ’ ğ’•ğ’‰ğ’† ğ’ğ’“ğ’…ğ’†ğ’“ ğ’ğ’‡ 10^7. ğ‘©ğ’†ğ’šğ’ğ’ğ’… ğ’•ğ’‰ğ’Šğ’” ğ’˜ğ’† ğ’˜ğ’Šğ’ğ’ ğ’‡ğ’‚ğ’„ğ’† ğ’ğ’†ğ’ğ’ğ’“ğ’š ğ’Šğ’”ğ’”ğ’–ğ’†ğ’”.*/