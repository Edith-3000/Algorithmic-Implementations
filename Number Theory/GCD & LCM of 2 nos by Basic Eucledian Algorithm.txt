//ð’”ð’•ð’…::ð’ˆð’„ð’… | ð‘ª++ ð’Šð’ð’ƒð’–ð’Šð’ð’• ð’‡ð’–ð’ð’„ð’•ð’Šð’ð’ ð’‡ð’ð’“ ð’‡ð’Šð’ð’…ð’Šð’ð’ˆ ð‘®ð‘ªð‘« (ð‘¾ð‘¶ð‘¹ð‘²ð‘º ð‘¶ð‘µð‘³ð’€ ð‘­ð‘¶ð‘¹ ð’Šð’ð’•)
  __gcd(a, b);

=================================================================================================================

/*The algorithm is based on below facts.
  # If we subtract smaller number from larger (we reduce larger number), GCD doesnâ€™t change. 
    So if we keep subtracting repeatedly the larger of two, we end up with GCD.
  # Now instead of subtraction, if we divide smaller number, the algorithm stops when we find remainder 0.
*/

//RECURSIVE IMPLEMENTATION (Using Modulo)

long long gcd_by_basic_euclid(long long a, long long b)
{
	//base condition
	if(b==0) return a;
	return gcd_by_basic_euclid(b, a%b);
}

OR

long long gcd_by_basic_euclid(long long a, long long b){
	return b==0 ? a : gcd_by_basic_euclid(b, a%b);
}

//RECURSIVE IMPLEMENTATION (Using Subtraction)

long long gcd_by_basic_euclid(long long a, long long b)
{
	//base condition
	if(a==b) return a;
	else if(a>b) return gcd_by_basic_euclid(a-b, b);
	else return gcd_by_basic_euclid(a, b-a);
}

=================================================================================================================

//ITERATIVE IMPLEMENTATION (Using Modulo)

long long gcd_by_basic_euclid(long long a, long long b)
{
	while(b)
	{
	   long long temp=a%b; //swapping a & b
       a=b;
       b=temp;
	}

	return a;
}

//ITERATIVE IMPLEMENTATION (Using Modulo)

long long gcd_by_basic_euclid(long long a, long long b)
{
	while (a!=b)  
    {  
        if (a > b) a = a - b;        
        else b = b - a;      
    }  
    
    return a; 
}

=================================================================================================================

long long lcm_by_basic_euclid(long long a, long long b)
{
	long long g=gcd_by_basic_euclid(a, b); //calculating gcd
	return (a/g)*b; //since lcm*gcd=a*b
	                //to avoid overflow
}


/*Worst case of Basic Euclidean Algorithm: when a and b are 2 consecutive fibonacci nos.
  Time Complexity in worst case: O(logâ‚‚(max(a,b)))

  Best case of Basic Euclidean Algorithm: when a%b==0 or b%a==0
  Time Complexity in best case: O(1)
*/ 

=================================================================================================================

# EXTRAS --->
  * GCD(a, b) = GCD(|a|, |b|) for any integers a and b, at least one of which is nonzero.
    For eg. GCD(18, âˆ’12) = GCD(âˆ’18, 12) = GCD(âˆ’18, âˆ’12) = GCD(18, 12) = 6.
    6 divides all of 18, 12, âˆ’12, and âˆ’18; no greater integer divides all of those values.

    Source: https://www.quora.com/What-is-the-GCD-of-a-positive-and-a-negative-number/answer/Howard-Ludwig