//RECURSIVE IMPLEMENTATION

long long fast_modulo_exponent(long long a, long long b, long long p)
{
	//base conditions
	if(b==0) return 1;
	if(a==0) return 0;

	long long temp=fast_modulo_exponent(a, b/2, p);
	long long result=(temp * temp)%p;

	if(b&1) result=((a%p)*(result))%p;
	return (result+p)%p; // in case result comes out to be negative 
	                     // and we've to return the modulo value
}

// Time complexity: O(log₂b), where b is the exponent in aᵇ 

=================================================================================================================

//ITERATIVE IMPLEMENTATION
***𝑹𝒆𝒎𝒆𝒎𝒃𝒆𝒓, 𝒈𝒆𝒏𝒆𝒓𝒂𝒍𝒍𝒚 𝒊𝒕𝒆𝒓𝒂𝒕𝒊𝒗𝒆 𝒊𝒎𝒑𝒍𝒆𝒎𝒆𝒏𝒕𝒂𝒕𝒊𝒐𝒏𝒔 𝒂𝒓𝒆 "𝑭𝑨𝑺𝑻𝑬𝑹" 𝒕𝒉𝒂𝒏 𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝒊𝒎𝒑𝒍𝒆𝒎𝒆𝒏𝒕𝒂𝒕𝒊𝒐𝒏𝒔***

long long fast_modulo_exponent(long long a, long long b, long long p)
{
	a=a%p; // update a if a>=p
	if(a==0) return 0; // in case a is divisible by p

    long long result=1; //initialize result
    while(b>0)
    {
       if(b&1) result=(result*a)%p;
       a=(a*a)%p;
       b/=2; //or b=b>>1
    }

    return result;
}

// Time complexity: O(log₂b), where b is the exponent in aᵇ 

=================================================================================================================

//IMPLEMENTATION USING BITMASKS

long long fast_modulo_exponent(long long a. long long b, long long p)
{
	long long res=1;

	while(b>0)
	{
		if(b&1) res=(res*a)%p;
		a=(a*a)%p;
		b=b>>1;
	}

	return res;
}

// Time complexity: O(log₂b), ∵ there can be at most (log₂b) bits in the binary representation of b,
//                              where b is the exponent in aᵇ 