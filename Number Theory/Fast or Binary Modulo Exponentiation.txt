//RECURSIVE IMPLEMENTATION

/*CONCEPT: aáµ‡ = a * (a^(b/2))Â², when b is odd
		   aáµ‡ = (a^(b/2))Â², when b is even
*/   

long long fast_modulo_exponent(long long a, long long b, long long p)
{
	// base condition(s)
	if(b==0) return 1;
	if(a==0) return 0;

	long long temp=fast_modulo_exponent(a, b/2, p);
	long long result=(temp * temp)%p;

	if(b&1) result=((a%p)*(result))%p;
	return (result+p)%p; // in case result comes out to be negative 
	                     // and we've to return the modulo value
}

// Time complexity: O(logâ‚‚b), where b is the exponent in aáµ‡ 

=================================================================================================================

//ITERATIVE IMPLEMENTATION USING BITMASKS
***ð‘¹ð’†ð’Žð’†ð’Žð’ƒð’†ð’“, ð’ˆð’†ð’ð’†ð’“ð’‚ð’ð’ð’š ð’Šð’•ð’†ð’“ð’‚ð’•ð’Šð’—ð’† ð’Šð’Žð’‘ð’ð’†ð’Žð’†ð’ð’•ð’‚ð’•ð’Šð’ð’ð’” ð’‚ð’“ð’† "ð‘­ð‘¨ð‘ºð‘»ð‘¬ð‘¹" ð’•ð’‰ð’‚ð’ ð’“ð’†ð’„ð’–ð’“ð’”ð’Šð’—ð’† ð’Šð’Žð’‘ð’ð’†ð’Žð’†ð’ð’•ð’‚ð’•ð’Šð’ð’ð’”***

long long fast_modulo_exponent(long long a, long long b, long long p)
{
	a=a%p; // update a if a>=p
	if(a==0) return 0; // in case a is divisible by p

    long long result=1; //initialize result
    while(b>0)
    {
       if(b&1) result=(result*a)%p;
       a=(a*a)%p;
       b=b>>1; // or b/=2 
    }

    return result;
}

// Time complexity: O(logâ‚‚b), âˆµ there can be at most (logâ‚‚b) bits in the binary representation of b,
//                              where b is the exponent in aáµ‡ 
