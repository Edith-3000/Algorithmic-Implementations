/*PROBLEM STATEMENT: For a given number â€˜Nâ€™, write a function to generate all combination of â€˜Nâ€™ 
					 pairs of balanced parentheses.
					 Input: N=3
					 Output: ((())), (()()), (())(), ()(()), ()()()
*/

/*UNDERLYING CONCEPT ------>
  # This problem also follows the Subsets pattern and can be mapped to Permutations. 
    We can follow a similar BFS approach.
  # Taking example mentioned above to generate all the combinations of balanced parentheses. 
    Following a BFS approach, we will keep adding open parentheses '('or close parentheses ')'. 
    At each step we need to keep two things in mind:
    â™¦ ğ‘¾ğ’† ğ’„ğ’‚ğ’â€™ğ’• ğ’‚ğ’…ğ’… ğ’ğ’ğ’“ğ’† ğ’•ğ’‰ğ’‚ğ’ â€˜ğ‘µâ€™ ğ’ğ’‘ğ’†ğ’ ğ’‘ğ’‚ğ’“ğ’†ğ’ğ’•ğ’‰ğ’†ğ’”ğ’Šğ’”.
    â™¦ ğ‘»ğ’ ğ’Œğ’†ğ’†ğ’‘ ğ’•ğ’‰ğ’† ğ’‘ğ’‚ğ’“ğ’†ğ’ğ’•ğ’‰ğ’†ğ’”ğ’†ğ’” ğ’ƒğ’‚ğ’ğ’‚ğ’ğ’„ğ’†ğ’…, ğ’˜ğ’† ğ’„ğ’‚ğ’ ğ’‚ğ’…ğ’… ğ’‚ ğ’„ğ’ğ’ğ’”ğ’† ğ’‘ğ’‚ğ’“ğ’†ğ’ğ’•ğ’‰ğ’†ğ’”ğ’Šğ’” ) ğ’ğ’ğ’ğ’š ğ’˜ğ’‰ğ’†ğ’ ğ’˜ğ’† ğ’‰ğ’‚ğ’—ğ’† ğ’‚ğ’ğ’“ğ’†ğ’‚ğ’…ğ’š
      ğ’‚ğ’…ğ’…ğ’†ğ’… ğ’†ğ’ğ’ğ’–ğ’ˆğ’‰ ğ’ğ’‘ğ’†ğ’ ğ’‘ğ’‚ğ’“ğ’†ğ’ğ’•ğ’‰ğ’†ğ’”ğ’Šğ’” (. ğ‘­ğ’ğ’“ ğ’•ğ’‰ğ’Šğ’”, ğ’˜ğ’† ğ’„ğ’‚ğ’ ğ’Œğ’†ğ’†ğ’‘ ğ’‚ ğ’„ğ’ğ’–ğ’ğ’• ğ’ğ’‡ ğ’ğ’‘ğ’†ğ’ ğ’‚ğ’ğ’… ğ’„ğ’ğ’ğ’”ğ’† ğ’‘ğ’‚ğ’“ğ’†ğ’ğ’•ğ’‰ğ’†ğ’”ğ’Šğ’” 
      ğ’˜ğ’Šğ’•ğ’‰ ğ’†ğ’—ğ’†ğ’“ğ’š ğ’„ğ’ğ’ğ’ƒğ’Šğ’ğ’‚ğ’•ğ’Šğ’ğ’.

  # Following this guideline, letâ€™s generate parentheses for N=3:
    1. Start with an empty combination: ""
    2. At every step, letâ€™s take all combinations of the previous step and add ( or ) keeping the 
       above-mentioned two rules in mind.
    3. For the empty combination, we can add ( since the count of open parenthesis will be less than â€˜Nâ€™. 
       We canâ€™t add ) as we donâ€™t have an equivalent open parenthesis, so our list of combinations will
       now be: â€œ(â€
    4. For the next iteration, letâ€™s take all combinations of the previous set. For â€œ(â€ we can add another 
       ( to it since the count of open parenthesis will be less than â€˜Nâ€™. 
       We can also add ) as we do have an equivalent open parenthesis, so our list of combinations will be: â€œ((â€, â€œ()â€
    5. In the next iteration, for the first combination â€œ((â€, we can add another ( to it as the count of 
       open parenthesis will be less than â€˜Nâ€™, we can also add ) as we do have an equivalent open parenthesis.
       This gives us two new combinations: â€œ(((â€ and â€œ(()â€.
       For the second combination â€œ()â€, we can add another ( to it since the count of open parenthesis will be less than â€˜Nâ€™. We canâ€™t add ) as we donâ€™t have an equivalent open parenthesis, so our list of 
       combinations will be: â€œ(((â€, â€œ(()â€, ()("
    6. Following the same approach, next we will get the following list of combinations: 
       â€œ((()â€, â€œ(()(â€, â€œ(())â€, â€œ()((â€, â€œ()()â€
    7. Next we will get: â€œ((())â€, â€œ(()()â€, â€œ(())(â€, â€œ()(()â€, â€œ()()(â€
    8. Finally, we will have the following combinations of balanced parentheses: 
       â€œ((()))â€, â€œ(()())â€, â€œ(())()â€, â€œ()(())â€, â€œ()()()â€
    9. We canâ€™t add more parentheses to any of the combinations, so we stop here.
*/

#include<iostream>
#include<vector>
#include<string>
#include<queue>
using namespace std;

class ParenthesesStr
{
	public:
		// data members
		string str;
		int openCount=0; // open parentheses count
		int closeCount=0; // close parentheses count
		
		// constructor(member function)
		ParenthesesStr(string str, int openCount, int closeCount)
		{
			this->str=str;
			this->openCount=openCount;
			this->closeCount=closeCount;
		}
};

class Solve
{
	public:
		static vector<string> generateValidParentheses(int n)
		{
			vector<string> res;
			if(n<=0)
				return res;
				
			queue<ParenthesesStr> q;
			q.push({"", 0, 0});
			
			while(!q.empty())
			{
				ParenthesesStr ps=q.front();
				q.pop();
				
				// if we reached the maximum number of open and close parenzheses,
                // add it to the result
				if(ps.openCount==n && ps.closeCount==n)
					res.push_back(ps.str);
					
				else
				{
					// if we can add an open parentheses add it
					if(ps.openCount<n)
						q.push({ps.str + "(", ps.openCount+1, ps.closeCount});
					
					// if we can add an close parentheses add it
					if(ps.closeCount<ps.openCount)
						q.push({ps.str + ")", ps.openCount, ps.closeCount+1});
				}
			}
			
			// return the final result
			return res;
		}
};

int main(int argc, char *argv[])
{
	vector<string> res=Solve::generateValidParentheses(4);
	for(auto s: res){
		cout<<s<<" "<<"\n";
	} 
}

/*# Time complexity ---->
  # If we donâ€™t care for the ordering - that ) can only come after ( - then we have two options for 
    every position, i.e., either put open parentheses or close parentheses. 
    This means we can have a maximum of 2Â²â¿ combinations. Because of the ordering, the actual number 
    will be less than 2Â²â¿.
  # If we see the visual representation of Example given in problem statement closely it is realized 
    that, in the worst case, it is equivalent to a binary tree, where each node will have two children. 
    This means that we will have 2â¿ leaf nodes (âˆµ #ğ’ğ’†ğ’‚ğ’‡ ğ’ğ’ğ’…ğ’†ğ’” ğ’Šğ’ ğ’‚ ğ’‘ğ’†ğ’“ğ’‡ğ’†ğ’„ğ’• ğ’ƒğ’Šğ’ğ’‚ğ’“ğ’š ğ’•ğ’“ğ’†ğ’† ğ’ğ’‡ ğ’‰ğ’†ğ’Šğ’ˆğ’‰ğ’• ğ’‰ = 2Ê°).
    and 2â¿-1 intermediate nodes. (âˆµ #ğ’Šğ’ğ’•ğ’†ğ’“ğ’ğ’‚ğ’ ğ’ğ’ğ’…ğ’†ğ’” ğ’Šğ’ ğ’‚ ğ’‘ğ’†ğ’“ğ’‡ğ’†ğ’„ğ’• ğ’ƒğ’Šğ’ğ’‚ğ’“ğ’š ğ’•ğ’“ğ’†ğ’† ğ’ğ’‡ ğ’‰ğ’†ğ’Šğ’ˆğ’‰ğ’• ğ’‰ = (2Ê°-1).
    So the total number of elements pushed to the queue will be (2â¿+2â¿-1)=(2â¿âºÂ¹-1), which is 
    asymptotically equivalent to (2â¿).
â€‹â€‹  # While processing each element, we do need to concatenate the current string with ( or ). 
    This operation will take O(n).
    So the overall time complexity of algorithm will be O(n x 2â¿). 

  # NOTE: This is not completely accurate but reasonable enough to be presented in the interview.
  # The actual time complexity (O(4â¿/sqrt(n)) is bounded by the Catalan number.

  # Space complexity ---->
  # All the additional space used by algorithm is for the output list. 
    Since we canâ€™t have more than O(2â¿) combinations, the space complexity is O(n x 2â¿).
*/

================================================================================================================

// ALTERNATE RECURSIVE APPROACH

#include<iostream>
#include<vector>
#include<string>
#include<queue>
using namespace std;

class Solve
{
	public:
		static vector<string> generateValidParenthesesRecur(int n)
		{
			vector<string> res;
			if(n<=0)
				return res;
				
			vector<char> parenthesesStr(2*n);
			utility(n, 0, 0, 0, parenthesesStr, res);
			
			return res;
		}
	
	private:
		static void utility(int n, int openCount, int closeCount, 
					 int index, vector<char> &parenthesesStr, 
					 vector<string> &res)
		{
			// if we reached the maximum number of open and close parenzheses,
            // add it to the result
			if(openCount==n && closeCount==n)
			{
				res.push_back(string(parenthesesStr.begin(), parenthesesStr.end()));
				return;
			}
			
			else
			{
				// if we can add an open parentheses add it
				if(openCount<n)
				{
					parenthesesStr[index]='(';
					utility(n, openCount+1, closeCount, index+1, parenthesesStr, res);
				}
				
				// if we can add an close parentheses add it
				if(closeCount<openCount)
				{
					parenthesesStr[index]=')';
					utility(n, openCount, closeCount+1, index+1, parenthesesStr, res);
				}
			}
		}
};

int main(int argc, char *argv[])
{
	vector<string> res=Solve::generateValidParenthesesRecur(11);
	for(auto s: res){
		cout<<s<<" "<<"\n";
	} cout<<res.size();
}

// Time complexity:
// Space complexity: