/* Problem Statement: Given an array of â€˜Kâ€™ sorted LinkedLists, merge them into one sorted list.
*/

/*UNDERLYING CONCEPT ------>
  # A brute force solution could be to add all elements of the given â€˜Kâ€™ lists to one list and sort it.
  # If there are a total of â€˜Nâ€™ elements in all the input lists, then the brute force solution will have a 
    time complexity of O(N*logâ‚‚N) as we will need to sort the merged list. 
  # A better approach can be followed by utilizing ğ’•ğ’‰ğ’† ğ’‡ğ’‚ğ’„ğ’• ğ’•ğ’‰ğ’‚ğ’• ğ’•ğ’‰ğ’† ğ’Šğ’ğ’‘ğ’–ğ’• ğ’ğ’Šğ’”ğ’•ğ’” ğ’‚ğ’“ğ’† ğ’Šğ’ğ’…ğ’Šğ’—ğ’Šğ’…ğ’–ğ’‚ğ’ğ’ğ’š ğ’”ğ’ğ’“ğ’•ğ’†ğ’….

  # If we have to find the smallest element of all the input lists, we have to compare ğ’ğ’ğ’ğ’š ğ’•ğ’‰ğ’† ğ’”ğ’ğ’‚ğ’ğ’ğ’†ğ’”ğ’• 
    (ğ’Š.ğ’†. ğ’•ğ’‰ğ’† ğ’‡ğ’Šğ’“ğ’”ğ’•) ğ’†ğ’ğ’†ğ’ğ’†ğ’ğ’• ğ’ğ’‡ ğ’‚ğ’ğ’ ğ’•ğ’‰ğ’† ğ’ğ’Šğ’”ğ’•ğ’”. 
  # Once we have the smallest element, we can put it in the merged list. 
  # Following a similar pattern, we can then find the next smallest element of all the lists to add it to 
    the merged list.

  # ğ‘»ğ‘¯ğ‘¬ ğ‘©ğ‘¬ğ‘ºğ‘» ğ‘«ğ‘¨ğ‘»ğ‘¨ ğ‘ºğ‘»ğ‘¹ğ‘¼ğ‘ªğ‘»ğ‘¼ğ‘¹ğ‘¬ ğ‘»ğ‘¯ğ‘¨ğ‘» ğ‘ªğ‘¶ğ‘´ğ‘¬ğ‘º ğ‘»ğ‘¶ ğ‘´ğ‘°ğ‘µğ‘« ğ‘»ğ‘¶ ğ‘­ğ‘°ğ‘µğ‘« ğ‘»ğ‘¯ğ‘¬ ğ‘ºğ‘´ğ‘¨ğ‘³ğ‘³ğ‘¬ğ‘ºğ‘» ğ‘µğ‘¼ğ‘´ğ‘©ğ‘¬ğ‘¹ ğ‘¹ğ‘¬ğ‘·ğ‘¬ğ‘¨ğ‘»ğ‘¬ğ‘«ğ‘³ğ’€ 
    ğ‘¨ğ‘´ğ‘¶ğ‘µğ‘® ğ‘¨ ğ‘ºğ‘¬ğ‘» ğ‘¶ğ‘­ â€˜ğ‘²â€™ ğ‘µğ‘¼ğ‘´ğ‘©ğ‘¬ğ‘¹ğ‘º ğ‘°ğ‘º ğ‘¨ ğ‘¯ğ‘¬ğ‘¨ğ‘·. 

  # Letâ€™s see how can we use a heap to find a better algorithm.
    * We can insert the first element of each array in a Min Heap.
    * After this, we can take out the smallest (top) element from the heap and add it to the merged 
      list.
    * After removing the smallest element from the heap, we can insert the next element of the ğ’”ğ’‚ğ’ğ’† list 
      into the heap.
    * We can repeat steps 2 and 3 to populate the merged list in sorted order.
*/

/*
 * Definition for singly-linked list.
 * struct node {
 *     int val;
 *     node *next;
 *     node() : val(0), next(nullptr) {}
 *     node(int x) : val(x), next(nullptr) {}
 *     node(int x, Node *next) : val(x), next(next) {}
 * };
 */

node* mergeKSortedLists(vector<node *> &v)
{
    struct comparator
    {
       bool operator()(const node *x, const node *y)
       {
          return x->val > y->val;
       }
    };

	  priority_queue<node *, vector<node *>, comparator> minHeap;
	
    //push the root of each list in minHeap
	  for(auto root: v)
	  {
	     if(root!=nullptr)
	        minHeap.push(root);
	  }
    
    //initialising the head and tail(for easy insertion) of
    //the resultant final list
    node *resHead=nullptr, *resTail=nullptr;
 
    //take the smallest(top) element from the minHeap and add
    //it to the result, if the top element has next element 
    //present then add it to the minHeap 
	  while(!minHeap.empty())
	  {
	     node *t= minHeap.top();
	     minHeap.pop();

	     if(resHead==nullptr)
	        resHead=resTail=t;

	     else
	     {
	        resTail->next=t;
	        resTail=resTail->next;
	     }

	     if(t->next!=nullptr)
	        minHeap.push(t->next);
	  }

	  return resHead;
}

/* # v[] is a vector of pointers containing pointers to node data type.
   # Since weâ€™ll be going through all the elements of all arrays and will be removing/adding one element 
     to the heap in each step, the time complexity of the above algorithm will be O(N*logK), where â€˜Nâ€™ is 
     the total number of elements in all the â€˜Kâ€™ input arrays.
   # Space complexity: The space complexity will be O(K) because, at any time, our min-heap will be 
                       storing one number from all the â€˜Kâ€™ input arrays.
*/