# In computer science, a trie, also called ğ’…ğ’Šğ’ˆğ’Šğ’•ğ’‚ğ’ ğ’•ğ’“ğ’†ğ’† or ğ’‘ğ’“ğ’†ğ’‡ğ’Šğ’™ ğ’•ğ’“ğ’†ğ’†, is a kind of search treeâ€”an ordered 
  tree data structure used to store a dynamic set or associative array where the keys are usually strings.

# Trie is an efficient information reğ‘»ğ’“ğ’Šğ’†val data structure. 
  Using Trie, search complexities can be brought to optimal limit (key length). 

# Trie is basically an n-ary tree.

# If we store keys in binary search tree, a well balanced BST will need time proportional to M * log N, 
  where M is maximum string length and N is number of keys in tree. 
  Using Trie, we can search the key in O(M) time. However the penalty is on ğ‘»ğ’“ğ’Šğ’† ğ’”ğ’•ğ’ğ’“ğ’‚ğ’ˆğ’† ğ’“ğ’†ğ’’ğ’–ğ’Šğ’“ğ’†ğ’ğ’†ğ’ğ’•ğ’”.

# Every node of Trie consists of multiple branches. Each branch represents a possible character of keys.
  We need to mark the last node of every key as end of word node (i.e. terminal).

# Inserting a key into Trie is a simple approach. Every character of the input key is inserted as an 
  individual Trie node. Note that the children is an array of pointers (or references) (or it can be a 
  hash map also) to next level trie nodes. The key character acts as an index into the array children. 
  If the input key is new or an extension of the existing key, we need to construct non-existing nodes of 
  the key, and mark end of the word for the last node. If the input key is a prefix of the existing key 
  in Trie, we simply mark the last node of the key as the end of a word. 
  The key length determines Trie depth.

# Searching for a key is similar to insert operation, however, we only compare the characters and move down.
  The search can terminate due to the end of a string or lack of key in the trie. 
  In the former case, if the terminal data member of the last node is true, then the key exists in the trie.
  In the second case, the search terminates without examining all the characters of the key, since the key 
  is not present in the trie.

# Insert, search and delete costs ğ‘¶(ğ’Œğ’†ğ’š_ğ’ğ’†ğ’ğ’ˆğ’•ğ’‰), however the memory requirements of Trie is: 
  ğ‘¶(ğ‘¨ğ‘³ğ‘·ğ‘¯ğ‘¨ğ‘©ğ‘¬ğ‘»_ğ‘ºğ‘°ğ’ğ‘¬ * ğ’Œğ’†ğ’š_ğ’ğ’†ğ’ğ’ˆğ’•ğ’‰ * ğ‘µ) where N is number of keys in Trie. 
  There are efficient representation of trie nodes (e.g. compressed trie, ternary search tree, etc.) to
  minimize memory requirements of trie.

# ğ‘¨ ğ’„ğ’ğ’ğ’ğ’ğ’ ğ’‚ğ’‘ğ’‘ğ’ğ’Šğ’„ğ’‚ğ’•ğ’Šğ’ğ’ ğ’ğ’‡ ğ’‚ ğ’•ğ’“ğ’Šğ’† ğ’Šğ’” ğ’”ğ’•ğ’ğ’“ğ’Šğ’ğ’ˆ ğ’‚ ğ’…ğ’Šğ’„ğ’•ğ’Šğ’ğ’ğ’‚ğ’“ğ’š, ğ’”ğ’–ğ’„ğ’‰ ğ’‚ğ’” ğ’ğ’ğ’† ğ’‡ğ’ğ’–ğ’ğ’… ğ’ğ’ ğ’‚ ğ’ğ’ğ’ƒğ’Šğ’ğ’† ğ’•ğ’†ğ’ğ’†ğ’‘ğ’‰ğ’ğ’ğ’†. 
  ğ‘ºğ’–ğ’„ğ’‰ ğ’‚ğ’‘ğ’‘ğ’ğ’Šğ’„ğ’‚ğ’•ğ’Šğ’ğ’ğ’” ğ’•ğ’‚ğ’Œğ’† ğ’‚ğ’…ğ’—ğ’‚ğ’ğ’•ğ’‚ğ’ˆğ’† ğ’ğ’‡ ğ’‚ ğ’•ğ’“ğ’Šğ’†â€™ğ’” ğ’‚ğ’ƒğ’Šğ’ğ’Šğ’•ğ’š ğ’•ğ’ ğ’’ğ’–ğ’Šğ’„ğ’Œğ’ğ’š ğ’”ğ’†ğ’‚ğ’“ğ’„ğ’‰ ğ’‡ğ’ğ’“, ğ’Šğ’ğ’”ğ’†ğ’“ğ’•, ğ’‚ğ’ğ’… ğ’…ğ’†ğ’ğ’†ğ’•ğ’† ğ’†ğ’ğ’•ğ’“ğ’Šğ’†ğ’”.