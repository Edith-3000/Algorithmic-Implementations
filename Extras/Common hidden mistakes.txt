# If the algorithm seems very robust but still don't give desired result, then check for the following
  parameters --------->
1. There might be possibility of ğ‘ºğ’†ğ’ˆğ’ğ’†ğ’ğ’•ğ’‚ğ’•ğ’Šğ’ğ’ ğ‘­ğ’‚ğ’–ğ’ğ’•.

2. It is possible that the fâ¿ name or variable name you are using is a ğ’Œğ’†ğ’šğ’˜ğ’ğ’“ğ’… in the language.

3. See if the #ğ‘»ğ’†ğ’”ğ’• ğ‘ªğ’‚ğ’”ğ’†ğ’” are correct.

4. Be cautious whether you've passed the arguements to fâ¿s. by ğ’“ğ’†ğ’‡ğ’†ğ’“ğ’†ğ’ğ’„ğ’† or by ğ’„ğ’ğ’‘ğ’š.

5. See if you're using ğ’„ğ’ğ’“ğ’“ğ’†ğ’„ğ’• ğ’Šğ’ğ’…ğ’†ğ’™ğ’Šğ’ğ’ˆ either 0 - based or 1 - based.

6. Don't ever use indexing to insert in container if their size hasn't been declared beforehand.
   Eg. vector<int> v;
       Then don't ever use v[i]=100;
       This will always give ğ‘ºğ’†ğ’ˆğ’ğ’†ğ’ğ’•ğ’‚ğ’•ğ’Šğ’ğ’ ğ‘­ğ’‚ğ’–ğ’ğ’• (ğ’„ğ’ğ’“ğ’† ğ’…ğ’–ğ’ğ’‘ğ’†ğ’…).
       To correct it either use v.push_back(100);
                     or declare vector size i.e. vector<int> v(size);

7. Always check if there is only 1 ğ’•ğ’†ğ’”ğ’• ğ’„ğ’‚ğ’”ğ’† in i/p, ğ’„ğ’ğ’ğ’ğ’†ğ’ğ’• ğ’ğ’–ğ’• ğ’•ğ’‰ğ’† ğ’ğ’Šğ’ğ’† ğ’„ğ’Šğ’>>ğ’• ğ’Šğ’ ğ’šğ’ğ’–ğ’“ ğ’•ğ’†ğ’ğ’‘ğ’ğ’‚ğ’•ğ’†.

8. Check for the ğ‘¬ğ‘«ğ‘®ğ‘¬ ğ‘ªğ‘¨ğ‘ºğ‘¬ğ‘º.

9. Remember, most of the times ğ‘ºğ‘¨ğ‘´ğ‘·ğ‘³ğ‘¬ ğ‘°/ğ‘· & ğ‘¶/ğ‘· given are ğ‘´ğ‘°ğ‘ºğ‘³ğ‘¬ğ‘¨ğ‘«ğ‘°ğ‘µğ‘®.

9. Don't ğ‘¨ğ‘ºğ‘ºğ‘¼ğ‘´ğ‘¬ ğ’‚ğ’ğ’šğ’•ğ’‰ğ’Šğ’ğ’ˆ by ğ’šğ’ğ’–ğ’“ğ’”ğ’†ğ’ğ’‡, follow the things written in problem statement, no self assumption.

10. Sometimes there are questions having possibility of ğ‘´ğ‘¼ğ‘³ğ‘»ğ‘°ğ‘·ğ‘³ğ‘¬ ğ‘¨ğ‘µğ‘ºğ‘¾ğ‘¬ğ‘¹ğ‘º, so if the o/p doesn't 
    matches with the eg. o/p just submit the code and check if answer is correct or not.

11. Always analyze the ğ‘ªğ‘¶ğ‘µğ‘ºğ‘»ğ‘¹ğ‘¨ğ‘°ğ‘µğ‘»ğ‘º very carefully, sometimes the answer lies in the constraints.

12. Don't ğ‘©ğ‘³ğ‘°ğ‘µğ‘«ğ‘³ğ’€ make the data type of std::vector as ğ’Šğ’ğ’•, as it becomes a habit many a times.

13. In C++ we can omit the curly braces after if-else statements, or after any loop. If we do not use 
    curly braces then only one statement after the if-else or loop will be considered under that block.
    ğ‘©ğ’–ğ’• ğ‘¹ğ‘¬ğ‘´ğ‘¬ğ‘´ğ‘©ğ‘¬ğ‘¹, ğ’‡ğ’–ğ’ğ’„ğ’•ğ’Šğ’ğ’ ğ’…ğ’†ğ’‡ğ’Šğ’ğ’Šğ’•ğ’Šğ’ğ’ğ’” ğ’‚ğ’“ğ’† ğ’•ğ’ ğ’ƒğ’† ğ’Šğ’ğ’„ğ’ğ’–ğ’…ğ’†ğ’… ğ’Šğ’ ğ’„ğ’–ğ’“ğ’ğ’š { } ğ’ƒğ’“ğ’‚ğ’„ğ’†ğ’”, ğ’†ğ’—ğ’†ğ’ ğ’Šğ’‡ ğ’•ğ’‰ğ’† ğ’‡ğ’–ğ’ğ’„ğ’•ğ’Šğ’ğ’ 
    ğ’…ğ’†ğ’‡ğ’Šğ’ğ’Šğ’•ğ’Šğ’ğ’ ğ’Šğ’” ğ’ğ’‡ 1 ğ’ğ’Šğ’ğ’† ğ’ğ’ğ’ğ’š, ğ’ğ’•ğ’‰ğ’†ğ’“ğ’˜ğ’Šğ’”ğ’† ğ’‡ğ’ğ’ğ’ğ’ğ’˜ğ’Šğ’ğ’ˆ ğ’†ğ’“ğ’“ğ’ğ’“ ğ’˜ğ’Šğ’ğ’ ğ’ƒğ’† ğ’”ğ’‰ğ’ğ’˜ğ’ ğ’ƒğ’š ğ’•ğ’‰ğ’† ğ’„ğ’ğ’ğ’‘ğ’Šğ’ğ’†ğ’“: 
    "ğ’ğ’‚ğ’ğ’†ğ’… ğ’“ğ’†ğ’•ğ’–ğ’“ğ’ ğ’—ğ’‚ğ’ğ’–ğ’†ğ’” ğ’‚ğ’“ğ’† ğ’ğ’ ğ’ğ’ğ’ğ’ˆğ’†ğ’“ ğ’”ğ’–ğ’‘ğ’‘ğ’ğ’“ğ’•ğ’†ğ’…".

14. A vector isn't always of ğ’”ğ’Šğ’›ğ’† ğ’. ğŸ˜ğŸ˜

15. Make sure you aren't using 'if' instead of 'while' or 'for' instead of 'if'.

16. Read question very carefullt, don't ğ‘¨ğ‘ºğ‘ºğ‘¼ğ‘´ğ‘¬ ğ‘¨ğ‘µğ’€ğ‘»ğ‘¯ğ‘°ğ‘µğ‘® ğ‘©ğ’€ ğ’€ğ‘¶ğ‘¼ğ‘¹ğ‘ºğ‘¬ğ‘³ğ‘­.

17. While doing division always be extra careful that there might be a possibility that the divisor may be 0 
    which may lead to Runtime Error or NaN.

18. std::unordered_map<> might give you "TLE" in some cases whereas std::map<> might not, this might be possible
    due to collisions in std::unordered_map<>.
    Unordered map might take O(n) as well in some cases. 
    For eg. see these 2 submissions for the same problem: 
    https://codeforces.com/contest/1374/submission/106730383
    https://codeforces.com/contest/1374/submission/106730707

    Same might be true for std::map<> also.
    So use them nicely.

    Nice blog: https://codeforces.com/blog/entry/62393

19. For "Multidimensional ARRAYS (i.e. 2D or higher dimensionsl)" their sizes MUST be known at the compile time,
    otherwise it will always give wrong or absurd answer or compile time error.
    Also for 1D arrays it is better to specify their size beforehand as it gives error sometime and sometimes 
    do not, so be on the safe side :)