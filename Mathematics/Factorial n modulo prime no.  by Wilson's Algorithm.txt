/*Used to compute n! under modulo p, where p is necessarily a prime no.
Note that n! % p = 0 if n >= p.
Wilson's algorithm is mainly useful - 1) p is a prime
                                      2) n<p
                                      3) when p is close to input number n.
*/

long long gcd(long long a, long long b)
{
	if(a==0) return b;
	else return gcd(b%a, a);
}

long long fast_exponent(long long a, long long b, long long p)
{
	a=a%p; //update a if a>=p
	if(a==0) return 0; //in case a is divisible by p

    long long result=1; //initialize result
    while(b>0)
    {
       if(b&1) result=(result*a)%p;
       a=(a*a)%p;
       b/=2; //or b=b>>1
    }

    return result;
}

long long modulo_mul_inv(long long n, long long p)
{
	/*function to find modular multi inverse of n under modulo p 
      using Fermat's Little Theorem. Assumption: p is prime 
	*/
	
	long long g=gcd(n, p);
	if(g!=1) return -1; //i.e. if n & p are not co-primes then modulo_mul_inv 
	                   //for n does not exist under modulo p

	else return fast_exponent(n, p-2, p); //a^-1 â‰¡ a^(m-2) (mod m)
}

long long wilson_algo(long long n, long long p)
{
	if(p<=n) return 0; //n! % p = 0 if n >= p
	long long res=p-1; //initialize result for (p-1)! which is -1 or (p-1) 

	for(long long i=n+1; i<p; i++) //multiply modulo multiplicative inverses of all nos. from n+1 to p-1 under modulo p
	  res=(res * modulo_mul_inv(i, p))%p;

	return res;
}

//Time complexity: O((p-n)*Logn) 
//remember n is close to p 