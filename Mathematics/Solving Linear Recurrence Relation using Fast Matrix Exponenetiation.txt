/*A linear recurrence relation is a function or a sequence such that each term is a linear combination of previous terms. 
  Each term can be described as a function of the previous terms. A famous example is the Fibonacci sequence: f(i) = f(i-1) + f(i-2).
  Linear means that the previous terms in the definition are only multiplied by a constant (possibly zero) and nothing else.

  Following is the approach to solve and find the nth term of LINEAR RECURRENCE RELATIONS.
  Below code is for the following Linear Recurenc Relation: F(n) = F(n-1) + F(n-2) + F(n-3), for n >= 3 
                                                            Base Cases : F(0) = 0, F(1) = 1, F(2) = 1 
  Similar Approach can be used to solve for other Linear Recurrence Relations, by little modifications in the code.
*/

//USING ITERATIVE FAST MATRIX EXPONENTIATION METHOD

void matrix_multiply(vector<vector<long long>> &a, const vector<vector<long long>> &b)
{
	vector<vector<long long>> c(3, vector<long long>(3)); //for storing the result
	for(long long i=0; i<3; i++)
	{
	   for(long long j=0; j<3; j++)
	   {
	      c[i][j]=0;
	      for(long long k=0; k<3; k++)
	        c[i][j]+=a[i][k]*b[k][j];
	   }
	}

	for(long long i=0; i<3; i++) //copying result back to a
	{
	   for(long long j=0; j<3; j++)
	     a[i][j]=c[i][j];
	}
}

void fast_matrix_exponentiation(vector<vector<long long>> &v, long long n)
{
	vector<vector<long long>> res(3, vector<long long>(3)); //very much similar to fast_exponentiation for nos.
	for(long long i=0; i<3; i++) //initializing res as an identity matrix 
	{
	    for(long long j=0; j<3; j++)
	    {
	        if(i==j) res[i][j]=1;
	        else res[i][j]=0;
	    }
	}

	while(n)
	{
	   if(n&1) matrix_multiply(res, v);
	   matrix_multiply(v, v);
	   n/=2;
	}

	for(long long i=0; i<3; i++) //copying the res back to v, as v was original matrix
	{
	   for(long long j=0; j<3; j++)
	     v[i][j]=res[i][j];
	}
}

long long find_nth_term_of_linear_recur_relation(long long n)
{
	//base cases
    if(n==0) return 0;
    if(n==1 || n==2) return 1;       

	vector<vector<long long>> v{{1, 1, 1}, {1, 0, 0}, {0, 1, 0}}; //v is the Transformation matrix, initialization may vary acc. to question
	vector<long long> constants{1, 1, 0}; //constants[0]=F[2], constants[1]=F[1], constants[2]=F[0]
	                                     //constants vector stores the base cases values.

    fast_matrix_exponentiation(v, n-2); //computes (Matrix v)^(n-2) in O(logn) time
                                       //The power raised may vary acc. to question
    long long res=0; //initialize final result
    for(long long k=0; k<3; k++) //1st row of matrix v is multiplied with the column vector constants
      res+=(v[0][k]*constants[k]);

    return res; 
}


//Time Complexity: O(k^3 * logn) //where k is the size of Transformation matrix v

***************************************************************************************************************************

//USING RECURSIVE FAST MATRIX EXPONENTIATION METHOD
(Remember Recursive methods are more costly than iterative methods)

void matrix_multiply(vector<vector<long long>> &a, vector<vector<long long>> &b)
{
	vector<vector<long long>> c(3, vector<long long>(3)); //for storing the result
	for(long long i=0; i<3; i++)
	{
	   for(long long j=0; j<3; j++)
	   {
	      c[i][j]=0;
	      for(long long k=0; k<3; k++)
	        c[i][j]+=a[i][k]*b[k][j];
	   }
	}

	for(long long i=0; i<3; i++) //copying result back to a
	{
	   for(long long j=0; j<3; j++)
	     a[i][j]=c[i][j];
	}
}

long long fast_matrix_exponentiation(vector<vector<long long>> &v, long long n)
{
	//base case of recursive function
    if(n==1) return v[0][0]+v[0][1];

	vector<vector<long long>> temp(v.begin(), v.end());
	
	fast_matrix_exponentiation(v, n/2);
	matrix_multiply(v, v);
	if(n&1) matrix_multiply(v, temp);
	
	return v[0][0]+v[0][1];
}

long long find_nth_term_of_linear_recur_relation(long long n)
{
	//base cases
    if(n==0) return 0;
    if(n==1 || n==2) return 1;       

	vector<vector<long long>> v{{1,1,1}, {1,0,0}, {0,1,0}};
	
    return fast_matrix_exponentiation(v, n-2);
}

//Time Complexity: O(k^3 * logn) //where k is the size of Transformation matrix v

****************************************************************************************************************************
//VERY IMPORTANT NOTE -
  
  *For the query of nth number which is 1 based indexing i.e. if user asks for 1st term or 2nd term & so on...... (not for 0th term, 1st term & so on)
     1) If smallest base case defined is F(1), then find T^(n-k), where T is the Transformation matrix,
                                                                        k is the size of Transformation matrix
     2) If smallest base case defined is F(0), such as in case of Fibonacci Sequence, then find T^(n-k+1), where T is the Transformation matrix,
                                                                                                           k is the size of Transformation matrix