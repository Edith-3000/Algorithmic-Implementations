//RECURSIVE IMPLEMENTATION

long long fast_exponent(long long a, long long b, long long p)
{
	//base conditions
	if(b==0) return 1;
	if(a==0) return 0;

	long long temp=fast_exponent(a, b/2);
	long long result=(temp * temp)%p;

	if(b&1) result=((a%p)*(result))%p;
	return (result+p)%p; //in case result comes out to be negative 
	                    //and we've to return the modulo value
}


//ITERATIVE IMPLEMENTATION
***Remember, generally iterative implementations are "faster" than recursive implementations***

long long fast_exponent(long long a, long long b, long long p)
{
	a=a%p; //update a if a>=p
	if(a==0) return 0; //in case a is divisible by p

    long long result=1; //initialize result
    while(b>0)
    {
       if(b&1) result=(result*a)%p;
       a=(a*a)%p;
       b/=2; //or b=b>>1
    }

    return result;
}