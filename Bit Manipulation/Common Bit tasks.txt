//ğ‘µğ‘¶ğ‘»ğ‘¬: ğ‘°ğ’ ğ’‚ğ’ğ’ ğ’•ğ’‰ğ’† ğ’ƒğ’†ğ’ğ’ğ’˜ ğ’„ğ’ğ’…ğ’†ğ’” 0 ğ’ƒğ’‚ğ’”ğ’†ğ’… ğ’Šğ’ğ’…ğ’†ğ’™ğ’Šğ’ğ’ˆ ğ’ğ’‡ ğ’ƒğ’Šğ’•ğ’” ğ’‡ğ’“ğ’ğ’ ğ‘¹ğ‘¯ğ‘º ğ’•ğ’ ğ‘³ğ‘¯ğ‘º (ğ’Š.ğ’†. ğ’‡ğ’“ğ’ğ’ ğ‘³ğ‘ºğ‘© ğ’•ğ’ ğ‘´ğ‘ºğ‘©) ğ’Šğ’” 
//ğ’„ğ’ğ’ğ’”ğ’Šğ’…ğ’†ğ’“ğ’†ğ’…

//CHECK IF A NUMBER IS ODD or EVEN

bool isOdd(int n)
{
	if(n & 1) //number is odd
	   return true;

	else //number is even
	   return false;
}

*****************************************************************************************************************

//GET(FIND) THE iáµ—Ê° BIT

int getBit(int n, int i)
{
	int mask=1<<i;
	int bit = (n & mask) > 0 ? 1 : 0;
	return bit;
}

*****************************************************************************************************************

//SET THE iáµ—Ê° BIT

int setBit(int n, int i)
{
	int mask=1<<i;
	int res = n | mask;
	return res;
}

*****************************************************************************************************************

//CLEAR THE iáµ—Ê° BIT

int clearBit(int n, int i)
{
	int mask = ~(1 << i);
	int res = n & mask;
	return res;
}

*****************************************************************************************************************

//UPDATE THE iáµ—Ê° BIT to v (v can be either 0 or 1)

int updateBit(int n, int i, int v)
{
	// first clear the ith bit
	int mask = ~(1 << i);
	int cleared_n = n & mask;

	//return updated number
	return cleared_n | (v << i);
}

*****************************************************************************************************************

//CLEAR THE LAST i BITS i.e. CLEAR THE BITS FROM (0áµ—Ê° BIT TO iáµ—Ê° BIT)

// -1 ğ’Šğ’ 2'ğ’” ğ‘ªğ‘¶ğ‘´ğ‘·ğ‘³ğ‘¬ğ‘´ğ‘¬ğ‘µğ‘» ğ‘¹ğ‘¬ğ‘·ğ‘¹ğ‘¬ğ‘ºğ‘¬ğ‘µğ‘»ğ‘¨ğ‘»ğ‘°ğ‘¶ğ‘µ (ğ’˜ğ’‰ğ’Šğ’„ğ’‰ ğ’Šğ’” ğ’•ğ’‰ğ’† ğ’“ğ’†ğ’‘ğ’“ğ’†ğ’”ğ’†ğ’ğ’•ğ’‚ğ’•ğ’Šğ’ğ’ ğ’–ğ’”ğ’†ğ’… ğ’ƒğ’š ğ’•ğ’‰ğ’† ğ’ğ’‚ğ’„ğ’‰ğ’Šğ’ğ’†ğ’”) = 
//                                                                          11111111111111111......

int clearLastIBits(int n, int i)
{
	int mask = (-1 << i); // mask = (~0) << i can also be used 
	                      // as binary of -1 and ~0 are equivalent
	return n & mask;
}

*****************************************************************************************************************

//CLEAR A RANGE OF BITS FROM (iáµ€á´´ BIT TO jáµ€á´´ BIT)

int clearRange_i_to_j(int n, int i, int j)
{
    // to form a number whose binary representation
    // is of the form 1111000000 
	int a = (-1) << (j+1); // mask = (~0) << (j+1) can also be used 

	// to form a number whose binary representation
    // is of the form 0000000111 (which is of the form
    // 2^n - 1, now 2^n can be represented as 1 << n)
    int b = (1 << i) - 1; 
    
    // mask will be of the form 1111000111
    int mask = a | b;
    return n & mask;
}

*****************************************************************************************************************

// MORE PRECISELY =====>

â€¢ Bit operation which can be used to set iáµ—Ê° bit of a number N from 0 to 1 => N |= (1 << i)
â€¢ Bit operation which can be used to set iáµ—Ê° bit of a number N from 1 to 0 => N &= ~(1 << i)
â€¢ Bit operation which can be used to flip(toggle) the iáµ—Ê° bit of a number N => N ^= (1 << i )
â€¢ Bit operation to get the index of 1Ë¢áµ— set bit(from LSB side) of a number N => log2(N & -N) "or" log2(N ^ (N & (N - 1)))
â€¢ Bit operation to clear the right most set bit(from LSB side) of a number N => N -= (N & -N)
â€¢ Bit operation which return "TRUE" if a number N is a power of 2 => return (x && !(x & (x - 1)))

* NOTE => 0 - based indexing of bits from LSB to MSB (right to left) is used.