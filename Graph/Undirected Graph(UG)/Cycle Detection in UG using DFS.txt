// ğ‘¨ğ’ ğ‘¼ğ’ğ’…ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ‘®ğ’“ğ’‚ğ’‘ğ’‰(ğ‘¼ğ‘®) ğ’„ğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’” ğ’‚ ğ’„ğ’šğ’„ğ’ğ’† ğ’Šğ’‡ ğ’•ğ’‰ğ’†ğ’“ğ’† ğ’Šğ’” ğ‘´ğ‘¶ğ‘¹ğ‘¬ ğ‘»ğ‘¯ğ‘¨ğ‘µ 1 ğ’˜ğ’‚ğ’š ğ’•ğ’ ğ’—ğ’Šğ’”ğ’Šğ’• ğ’‚ ğ’ğ’ğ’…ğ’†/ğ’—ğ’†ğ’“ğ’•ğ’†ğ’™.

bool cycleHelper(int src, vector<bool> &visited, int parent)
{
	// marking a node visited as soon as it is pushed in 
    // internal call stack
	visited[src]=true;

	// now there can be 2 cases -
	// 1. either the neighbour of the src vertex is not visited
	//    yet, in such a case recursively visit the neighbours 
	//    check for cycle or
	// 2. the neighbour is visited and != parent(src), (i.e backedge
	//    is present) then the graph contains cycle

	for(auto x: mp[src])
	{
		// case 1
		if(!visited[x])
		{
			// passing the parent of x as src
			bool cycleFound=cycleHelper(x, visited, src);
			if(cycleFound) return true;
		}

		// case 2
		else if(x!=parent) return true;
	}

	// if the above 2 cases fails then no cycle present
	return false;
}

bool containsCycle(int src)
{
    // to check if a vertex isVisited
	vector<bool> visited(n, false);

	// passing the parent of src vertex as -1
	// return the final result
	return cycleHelper(src, visited, -1);
}

// Time Complexity â‰¡ DFS traversal
// Here n is the number of vertices in the UG.
// m is the graph represented using unordered_map