/* # ğ‘©ğ‘¨ğ‘ªğ‘²ğ‘¬ğ‘«ğ‘®ğ‘¬ ğ‘°ğ‘º ğ‘¨ğ‘µ ğ‘¬ğ‘«ğ‘®ğ‘¬ ğ‘»ğ‘¯ğ‘¨ğ‘» ğ‘°ğ‘º ğ‘µğ‘¶ğ‘» ğ‘·ğ‘¶ğ‘°ğ‘µğ‘»ğ‘°ğ‘µğ‘® ğ‘»ğ‘¶ ğ‘»ğ‘¯ğ‘¬ ğ‘·ğ‘¨ğ‘¹ğ‘¬ğ‘µğ‘» ğ‘°ğ‘µ ğ‘¼ğ‘®.
   # ğ‘¾ğ‘¯ğ‘¬ğ‘¹ğ‘¬ğ‘½ğ‘¬ğ‘¹ ğ‘¨ ğ‘©ğ‘¨ğ‘ªğ‘²ğ‘¬ğ‘«ğ‘®ğ‘¬ ğ‘°ğ‘º ğ‘­ğ‘¶ğ‘¼ğ‘µğ‘« ğ‘©/ğ‘¾ ğ‘¨ğ‘µğ’€ 2 ğ‘µğ‘¶ğ‘«ğ‘¬ğ‘º ğ‘¾ğ‘¯ğ‘°ğ‘³ğ‘¬ ğ‘«ğ‘¶ğ‘°ğ‘µğ‘® ğ‘©ğ‘¹ğ‘¬ğ‘¨ğ‘«ğ‘»ğ‘¯-ğ‘­ğ‘°ğ‘¹ğ‘ºğ‘» ğ‘ºğ‘¬ğ‘¨ğ‘¹ğ‘ªğ‘¯ ğ‘¨ ğ‘ªğ’€ğ‘ªğ‘³ğ‘¬ 
     ğ‘°ğ‘º ğ‘·ğ‘¹ğ‘¬ğ‘ºğ‘¬ğ‘µğ‘» ğ‘°ğ‘µ ğ‘»ğ‘¯ğ‘¬ ğ‘®ğ‘¹ğ‘¨ğ‘·ğ‘¯.
   
   # Whenever the BFS process is initiated with a src vertx which is itself present in a cycle, then this
     process will give the correct length of the cycle in which it is present otherwise wrong answer.

   # Here the length of a cycle is taken as the number of edges in the cycle.
   # Now, in order to find the length of the shortest cycle in the graph we have to find all the ğ‘½ğ‘¨ğ‘³ğ‘°ğ‘«
     length cycles, which can be accomplished by doing the BFS from every node(i.e. taking every node as
     a src).
*/

int bfs(int src, int &res)
{
	// similar to the visited[] array
	vector<int> dis(n, INT_MAX);

	// queue to remember which vertex to visit next
	// in case of dead end in iteration
	queue<int> q;

	// distance of src from itself = 0
	dis[src]=0;

	// initialisation of the bfs process
	// pushing the src in queue
	q.push(src);

	while(!q.empty())
	{
		int curr=q.front();
		q.pop();

		// visiting all the adjacent vertices of src
		for(auto nbr: mp[curr])
		{
			// neighbour not visited, therefore it is 
			// is normal edge and not a backedge
			if(dis[nbr]==INT_MAX)
			{
				// updating the distance of nbr from src
				dis[nbr]=dis[curr]+1;
				q.push(nbr);
			}

			// backedge is encountered i.e. nbr has already
			// been visited and it is also not the parent of curr
			else if(dis[nbr]>=dis[curr])
			{
			    // updating the res
			    // the length of cycle in this case will be equal to
			    // dis[nbr] + dis[curr] + 1, (1 is for the backedge presents)
				res=min(res, dis[nbr]+dis[curr]+1);
			}
		}
	}

	// return final result
	return res;
}

int shortestCycleLen()
{
	int res=INT_MAX;
	for(int i=0; i<n; i++)
	{
		// res is to be passed by-reference
		bfs(i, res);
	}

	// if res not updated no cycle is present
	if(res==INT_MAX) return -1;

	// else return the length found
	else return res;
}

// here n is = |V|
// Note: Here an extra parent variable is not maintained to compare in the case when a nbr is already visited,
//       instead we've just used the fact that the distance[nbr]>=distance[curr], if nbr is already visited
//		 and not parent of curr, which is quiet obvious.
// Time Complexity: O(|V| x max(|V|, |E|))