# Reference: https://cp-algorithms.com/data_structures/disjoint_set_union.html

/********************************************************************************************************/

# ğ‘·ğ’‚ğ’•ğ’‰ ğ’„ğ’ğ’ğ’‘ğ’“ğ’†ğ’”ğ’”ğ’Šğ’ğ’ ğ’ğ’‘ğ’•ğ’Šğ’ğ’Šğ’›ğ’‚ğ’•ğ’Šğ’ğ’
  â€¢ This optimization is designed for speeding up find_set().
  â€¢ Pseudocode of the optimisation:
    
    int find_set(int v) {
		    // base condition
		    if(parent[v] == -1) return v;

        // otherwise
		    return parent[v] = find_set(parent[v]);
    }

// Time complexity: O(log(n) per call on average.

/********************************************************************************************************/

# ğ‘¼ğ’ğ’Šğ’ğ’ ğ’ƒğ’š ğ’”ğ’Šğ’›ğ’† / ğ’“ğ’‚ğ’ğ’Œ
  â€¢ This optimization is designed for speeding up union_sets().
  â€¢ Pseudocode of the optimisation:

    void make_set(int v) {
        parent[v] = -1;
    	  size[v] = 1;
    }

    void union_sets(int a, int b) {
        int s1 = find_set(a);
    	  int s2 = find_set(b);

    	  if(s1 != s2) {
    	      if(size[s1] < size[s2]) swap(s1, s2);
            parent[s2] = s1;
    		    size[s1] += size[s2];
    	  }
    }
    
    // DSU with union by size / rank, but without path compression works in O(log(n)) time per query.

/********************************************************************************************************/

# ğ‘°ğ’‡ ğ’˜ğ’† ğ’„ğ’ğ’ğ’ƒğ’Šğ’ğ’† ğ’ƒğ’ğ’•ğ’‰ ğ’ğ’‘ğ’•ğ’Šğ’ğ’Šğ’›ğ’‚ğ’•ğ’Šğ’ğ’ğ’” - ğ’‘ğ’‚ğ’•ğ’‰ ğ’„ğ’ğ’ğ’‘ğ’“ğ’†ğ’”ğ’”ğ’Šğ’ğ’ ğ’˜ğ’Šğ’•ğ’‰ ğ’–ğ’ğ’Šğ’ğ’ ğ’ƒğ’š ğ’”ğ’Šğ’›ğ’† / ğ’“ğ’‚ğ’ğ’Œ - ğ’˜ğ’† ğ’˜ğ’Šğ’ğ’ ğ’“ğ’†ğ’‚ğ’„ğ’‰ ğ’ğ’†ğ’‚ğ’“ğ’ğ’š 
  ğ‘ªğ‘¶ğ‘µğ‘ºğ‘»ğ‘¨ğ‘µğ‘» ğ‘¶(1) ğ’•ğ’Šğ’ğ’† ğ’’ğ’–ğ’†ğ’“ğ’Šğ’†ğ’”.