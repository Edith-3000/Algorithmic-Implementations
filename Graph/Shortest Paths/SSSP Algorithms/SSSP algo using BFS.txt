/* PROBLEM: Given an ğ’–ğ’ğ’˜ğ’†ğ’Šğ’ˆğ’‰ğ’•ğ’†ğ’… graph and a source, find shortest path from source to every other 
            node in the graph in most optimal way.
*/

/*UNDERLYING CONCEPT:
  # The idea is to use a slightly modified version of Breadth-first search.
  # ğ‘­ğ’ğ’“ ğ’‚ğ’ ğ‘¼ğ‘µğ‘¾ğ‘¬ğ‘°ğ‘®ğ‘¯ğ‘»ğ‘¬ğ‘« ğ‘®ğ‘¹ğ‘¨ğ‘·ğ‘¯(ğ’Š.ğ’†. ğ’‚ğ’ğ’ ğ’†ğ’…ğ’ˆğ’†ğ’” ğ’‰ğ’‚ğ’—ğ’Šğ’ğ’ˆ ğ’•ğ’‰ğ’† ğ‘ºğ‘¨ğ‘´ğ‘¬ ğ’˜ğ’†ğ’Šğ’ˆğ’‰ğ’•/ğ’„ğ’ğ’”ğ’•) ğ’•ğ’‰ğ’† ğ’ğ’†ğ’—ğ’†ğ’ ğ’ğ’“ğ’…ğ’†ğ’“ ğ’•ğ’“ğ’‚ğ’—ğ’†ğ’“ğ’”ğ’‚ğ’
    (ğ‘©ğ‘­ğ‘º) ğ’ˆğ’Šğ’—ğ’†ğ’” ğ’•ğ’‰ğ’† ğ’”ğ’‰ğ’ğ’“ğ’•ğ’†ğ’”ğ’• ğ’‘ğ’‚ğ’•ğ’‰.
*/

vector<T> ssspUsingBFS(T src)
{
    //to store the distance of all vertices
    //from src vertex, it'll also be used to
    //check if a vertex is already visited or not
	  unordered_map<T, T> d; 

    //initialising distances of all vertices from
    //source vertex (src) as infinite (i.e. very large)
    for(auto p: mp)
    {
       T v=p.first;
       d[v]=LLONG_MAX;
    }
    
    //distance of src from itself = 0
    d[src]=0;

	  //queue to remember which vertex to visit next
	  //in case of dead end in iteration
	  queue<T> q;

	  //initialisation of the bfs process
	  //pushing the src in queue
	  q.push(src);
	
	  //iterative process
	  while(!q.empty())
	  {
	     //taking out vertex from q
	     T v=q.front();
	     //popping out this vertex v from q
       q.pop();
       
       //visiting all the adjacent vertices of v
       for(const auto &x: mp[v])
       {
          //check if x is visited for the first 
          //time or not
          if(d[x]==LLONG_MAX)
          {
             //update the distance from src
             //i.e. d[child]=d[parent]+1
             d[x]=d[v]+1;
             //push it in the queue
             q.push(x);
          }
       }
	  }

	  //return the final result of traversal
	  return d;
}

/*# Here mp is an adjacency list representation of graph using hash map.
    unordered_map<T, list<T>> mp;
  # The Analysis of SSSP Algorithm using BFS â‰¡ Analysis of breadth-first search
*/