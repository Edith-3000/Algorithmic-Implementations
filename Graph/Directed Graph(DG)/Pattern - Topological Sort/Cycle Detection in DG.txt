// PROBLEM STATEMENT: Find if a given Directed Graph has a cycle in it or not.

===================================================================================================================

// ğ‘¼ğ‘ºğ‘°ğ‘µğ‘® ğ‘©ğ‘­ğ‘º 

/*UNDERLYING CONCEPT ------>
  # If we canâ€™t determine the topological ordering of all the vertices of a directed graph, the graph
    has a cycle in it i.e. for a directed cyclic graph : res.size()!=vertices (refer BFS implementation
    in "Topological Sort Algo.txt")
*/

===================================================================================================================

// ğ‘¼ğ‘ºğ‘°ğ‘µğ‘® ğ‘«ğ‘­ğ‘º

/* USEFUL TIPs âŸ¶
   # ğ‘¨ğ’ ğ‘¼ğ’ğ’…ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ‘®ğ’“ğ’‚ğ’‘ğ’‰(ğ‘¼ğ‘®) ğ’„ğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’” ğ’‚ ğ’„ğ’šğ’„ğ’ğ’† ğ’Šğ’‡ ğ’•ğ’‰ğ’†ğ’“ğ’† ğ’Šğ’” ğ‘´ğ‘¶ğ‘¹ğ‘¬ ğ‘»ğ‘¯ğ‘¨ğ‘µ 1 ğ’˜ğ’‚ğ’š ğ’•ğ’ ğ’—ğ’Šğ’”ğ’Šğ’• ğ’‚ ğ’ğ’ğ’…ğ’†/ğ’—ğ’†ğ’“ğ’•ğ’†ğ’™, but the same
     is not the case with ğ‘«ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ‘®ğ’“ğ’‚ğ’‘ğ’‰(ğ‘«ğ‘®), for eg. consider the following DG: 1 ----> 2
     																			  1 ----> 3
     																			  2 ----> 3
     â€¢ in this graph there are 2 ways to visit vertex 3:
       1). from 1 to 3
       2). from 1 to 2 to 3

       But it does not contain a cycle.
   # âˆ´ the same algo used in "Cycle Detection in UG using DFS.txt" can't be used.
   # ğ‘¨ ğ‘©ğ‘¨ğ‘ªğ‘²ğ‘¬ğ‘«ğ‘®ğ‘¬ ğ‘°ğ‘º ğ‘¨ğ‘µ ğ‘¬ğ‘«ğ‘®ğ‘¬ ğ‘­ğ‘¹ğ‘¶ğ‘´ ğ‘¨ ğ‘®ğ‘°ğ‘½ğ‘¬ğ‘µ ğ‘µğ‘¶ğ‘«ğ‘¬ ğ‘»ğ‘¶ ğ‘¨ğ‘µ ğ‘¨ğ‘µğ‘ªğ‘¬ğ‘ºğ‘»ğ‘¶ğ‘¹ ğ‘¶ğ‘­ ğ‘»ğ‘¯ğ‘¨ğ‘» ğ‘µğ‘¶ğ‘«ğ‘¬ ğ‘°ğ‘µ ğ‘»ğ‘¯ğ‘¬ ğ‘ºğ‘¨ğ‘´ğ‘¬ ğ‘·ğ‘¨ğ‘»ğ‘¯ ğ‘°ğ‘µ ğ‘¨ ğ‘«ğ‘®.
   # So to check cycle in a DG we maintain a ğ’”ğ’•ğ’‚ğ’„ğ’Œ ğ‘¨ğ‘¹ğ‘¹ğ‘¨ğ’€(it is also a bool array) in addition to the visited array.
     â€¢ As we know visited[] array basically keeps a check abput whether a given vertex has already been visited
       at some poit of time or not.
     â€¢ But here the extra data structure used which is the stack array (remember it is an array only, only the name
       name stack is used to convey the message that it will work almost similar to stack, but in order to have 
       a constant lookup time for a vertex an array is used in place of stack).
     â€¢ The stack[i] will be true for a vertex 'i' if the vertex is ğ’‚ ğ’‘ğ’‚ğ’“ğ’• ğ’ğ’‡ ğ’•ğ’‰ğ’† ğ’„ğ’–ğ’“ğ’“ğ’†ğ’ğ’• ğ’‘ğ’‚ğ’•ğ’‰.
*/

bool cycleHelper(int src, vector<bool> &visited, vector<bool> &stack)
{
	//marking a node visited as soon as it is pushed in 
    //internal call stack
	visited[src]=true;

	// the src now becomes a part of the current path
	stack[src]=true;

	// go to all the unvisited nodes of the current src
    // node, but one by one

    // now there can be 2 cases -
    // 1. either the neighbour of the src vertex is not visited
	//    yet, in such a case recursively visit the neighbours and
	//    check for cycle or
	// 2. the neighbour is visited and is also a part of the current path,
	//    then the graph contains cycle
	for(auto x: mp[src])
	{
		// case 1
		if(!visited[x])
		{
			bool cycleFound=cycleHelper(x, visited, stack);
			if(cycleFound) return true;
		}

		// case 2
		else if(stack[x]) return true;
	}

	// removing the current vertex i.e. src from the current path
	// when recursion moves in backward direction
	stack[src]=false;

	// if the above 2 cases fails then no cycle present
	return false;
}

bool containsCycle()
{
	vector<bool> visited(n, false);
	vector<bool> stack(n, false);
	
	// initially assuming that no cycle is present
	bool res=false;
	
	// check if cycle exists by iterating through 
	// all the vertices
	for(auto p: mp)
	{
		if(!visited[p.first]){
			bool temp=cycleHelper(p.first, visited, stack);
			res=res||temp;
		}
	}
	
	// return the final result
	return res;
}

/* # Why in the containsCycle fâ¿ cycleHelper fâ¿ is called for all the vertices(unvisited)?
     â€¢ This is because there might be a possibility that by calling containsCycle() for a single
       vertex, that DFS traversal might not traverse all the vertices in DG, for eg. take the case
       of the graph: with 4 vertices from 0 to 3 & 5 edges as follows- 1 ----> 2
																	   1 ----> 0
																	   2 ----> 3
																	   3 ----> 1
																	   3 ----> 0
	 â€¢ Here in this case if we perform DFS traversal only for once, say taking the src vertex as 0,
	   then it will give result as "No Cycle Present", but in reality cycle is present.
	 â€¢ âˆ´ we perform DFS from all the vertices, using a loop in the containsCycle() fâ¿.
*/

// Time Complexity â‰¡ DFS traversal
// Here n is the number of vertices in the UG.
// mp is the graph represented using unordered_map