/* PROBLEM STATEMENT: Topological Sort of a directed graph (a graph with unidirectional edges) is a 
                      linear ordering of its vertices such that for every directed edge (U, V) from vertex U 
                      to vertex V, U comes before V in the ordering.
					  Given a directed graph, find the topological ordering of its vertices.
					  Eg. Input: Vertices=5, Edges=[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]
						  Output: Following are all valid topological sorts for the given graph:
						          1) 4, 2, 3, 0, 1
						          2) 4, 3, 2, 0, 1
						          3) 4, 3, 2, 1, 0
						          4) 4, 2, 3, 1, 0
						          5) 4, 2, 0, 3, 1
*/

// USING BFS

/*UNDERLYING CONCEPT ------>
  # The basic idea behind the topological sort is to provide a partial ordering among the vertices of the
    graph such that if there is an edge from U to V then Uâ‰¤V i.e., U comes before V in the ordering. 
    Here are a few fundamental concepts related to topological sort:

	* Source: Any node that has no incoming edge and has only outgoing edges is called a source.
	* Sink: Any node that has only incoming edges and no outgoing edge is called a sink.

  # So, we can say that a topological ordering starts with one of the sources and ends at one of the sinks.

  # ğ‘¨ ğ’•ğ’ğ’‘ğ’ğ’ğ’ğ’ˆğ’Šğ’„ğ’‚ğ’ ğ’ğ’“ğ’…ğ’†ğ’“ğ’Šğ’ğ’ˆ ğ’Šğ’” ğ’‘ğ’ğ’”ğ’”ğ’Šğ’ƒğ’ğ’† ğ’ğ’ğ’ğ’š ğ’˜ğ’‰ğ’†ğ’ ğ’•ğ’‰ğ’† ğ’ˆğ’“ğ’‚ğ’‘ğ’‰ ğ’‰ğ’‚ğ’” ğ’ğ’ ğ’…ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ’„ğ’šğ’„ğ’ğ’†ğ’”, ğ’Š.ğ’†. ğ’Šğ’‡ ğ’•ğ’‰ğ’† ğ’ˆğ’“ğ’‚ğ’‘ğ’‰ ğ’Šğ’” 
    ğ’‚ ğ‘«ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ‘¨ğ’„ğ’šğ’„ğ’ğ’Šğ’„ ğ‘®ğ’“ğ’‚ğ’‘ğ’‰ (ğ‘«ğ‘¨ğ‘®). 
    If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find 
    a linear ordering among vertices.

  # To find the topological sort of a graph we can traverse the graph in a Breadth First Search (BFS) way. 
    We will start with all the sources, and in a stepwise fashion, save all sources to a sorted list. 
    We will then remove all sources and their edges from the graph. After the removal of the edges, we will have new sources, so we will repeat the above process until all vertices are visited.

  # Algorithmic steps --------->
    a. ğ‘°ğ’ğ’Šğ’•ğ’Šğ’‚ğ’ğ’Šğ’›ğ’‚ğ’•ğ’Šğ’ğ’
 	   1. We will store the graph in Adjacency Lists, which means each parent vertex will have a list 
 	      containing all of its children. We will do this using a HashMap where the â€˜keyâ€™ will be the 
 	      parent vertex number and the value will be a List containing children vertices.
	   2. To find the sources, we will keep a HashMap to count the in-degrees i.e., count of incoming edges 
	      of each vertex. Any vertex with â€˜0â€™ in-degree will be a source.
	
	b. ğ‘©ğ’–ğ’Šğ’ğ’… ğ’•ğ’‰ğ’† ğ’ˆğ’“ğ’‚ğ’‘ğ’‰ ğ’‚ğ’ğ’… ğ’‡ğ’Šğ’ğ’… ğ’Šğ’-ğ’…ğ’†ğ’ˆğ’“ğ’†ğ’†ğ’” ğ’ğ’‡ ğ’‚ğ’ğ’ ğ’—ğ’†ğ’“ğ’•ğ’Šğ’„ğ’†ğ’”
	   We will build the graph from the input and populate the in-degrees HashMap.

	c. ğ‘­ğ’Šğ’ğ’… ğ’‚ğ’ğ’ ğ’”ğ’ğ’–ğ’“ğ’„ğ’†ğ’”
	   All vertices with â€˜0â€™ in-degrees will be our sources and we will store them in a Queue.

	d. ğ‘ºğ’ğ’“ğ’•
	   For each source, do the following things:
	   1. Add it to the sorted list.
	   2. Get all of its children from the graph.
	   3. Decrement the in-degree of each child by 1.
	   4. If a childâ€™s in-degree becomes â€˜0â€™, add it to the sources Queue.
	   5. Repeat step 1, until the source Queue is empty.
*/

#include<iostream>
#include<vector>
#include<unordered_map>
#include<queue>
using namespace std;

class TopologicalSort
{
	public:
		static vector<int> sort(int vertices, const vector<vector<int>> &edges)
		{
			if(vertices<=0)
				return vector<int>();
				
			vector<int> res; // to store the final result

			// a. Initialize the graph 
			unordered_map<int, int> inDegree; // count of incoming edges for every vertex
			unordered_map<int, vector<int>> graph; // adjacency list graph
			for(int i=0; i<vertices; i++)
			{
				inDegree[i]=0;
				graph[i]=vector<int>();
			}
			
			// b. build the graph
			for(int i=0; i<edges.size(); i++)
			{
				int parent=edges[i][0], child=edges[i][1];
				graph[parent].push_back(child); // put the child into it's parent's list
				inDegree[child]++; // increment child's inDegree
			}
			
			// c. Find all sources i.e., all vertices with 0 in-degrees
			queue<int> q;
			for(auto entry: inDegree)
			{
				if(entry.second==0)
					q.push(entry.first);
			}
			
			// d. For each source, add it to the res and subtract one from all of its childrens'
			// in-degrees if a child's in-degree becomes zero, add it to the sources queue
			while(!q.empty())
			{
				int vertex=q.front();
				res.push_back(vertex);
				q.pop();
				vector<int> children=graph[vertex]; // get the node's children to decrement their in-degrees
				for(auto child: children)
				{
					inDegree[child]--;
					if(inDegree[child]==0)
						q.push(child);
				}
			}
			
			// topological sort is not possible if the graph has a cycle
			if(res.size()!=vertices)
				return vector<int>();
				
			return res; // return final result
		}
};

int main(int argc, char *argv[])
{
	vector<int> result=TopologicalSort::sort(7, vector<vector<int>>{vector<int>{6, 4}, vector<int>{6, 2}, vector<int>{5, 3},
	                                            					vector<int>{5, 4}, vector<int>{3, 0}, vector<int>{3, 1},
	                                            					vector<int>{3, 2}, vector<int>{4, 1}});	
	                                            					
	for(auto x: result)
	   cout<<x<<" ";                   		
}

// Time Complexity: O(|V|+|E|)
// Space Complexity: O(|V|+|E|)

======================================================================================================================================

// USING DFS
// ğ‘µğ‘¶ğ‘»ğ‘¬: ğ‘°ğ’ ğ’ğ’“ğ’…ğ’†ğ’“ ğ’•ğ’ ğ’–ğ’”ğ’† ğ’•ğ’‰ğ’† ğ‘«ğ‘­ğ‘º ğ’ğ’†ğ’•ğ’‰ğ’ğ’… ğ’‡ğ’ğ’“ ğ‘»ğ’ğ’‘ğ’ğ’ğ’ğ’ˆğ’Šğ’‚ğ’ ğ‘¶ğ’“ğ’…ğ’†ğ’“ğ’Šğ’ğ’ˆ, ğ’‡ğ’Šğ’“ğ’”ğ’• ğ’ğ’‚ğ’Œğ’† ğ’”ğ’–ğ’“ğ’† ğ’•ğ’‰ğ’‚ğ’• ğ’•ğ’‰ğ’† ğ’ˆğ’“ğ’‚ğ’‘ğ’‰ ğ’‰ğ’‚ğ’” ğ’ğ’ 
//        ğ’…ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ’„ğ’šğ’„ğ’ğ’†ğ’” ğ’‚ğ’• ğ’‚ğ’ğ’. ğ‘¯ğ’ğ’˜ğ’†ğ’—ğ’†ğ’“, ğ’Šğ’ ğ’ğ’“ğ’…ğ’†ğ’“ ğ’•ğ’ ğ’‚ğ’—ğ’ğ’Šğ’… ğ’„ğ’‰ğ’†ğ’„ğ’Œğ’Šğ’ğ’ˆ ğ’‘ğ’“ğ’†ğ’”ğ’†ğ’ğ’„ğ’† ğ’ğ’‡ ğ’„ğ’šğ’„ğ’ğ’† ğ’–ğ’”ğ’† ğ’•ğ’‰ğ’† ğ’‚ğ’ƒğ’ğ’—ğ’† ğ‘©ğ‘­ğ‘º ğ’ğ’†ğ’•ğ’‰ğ’ğ’….
//        ğ‘©ğ’–ğ’• ğ’†ğ’—ğ’†ğ’ ğ’Šğ’‡ ğ’šğ’ğ’– ğ’˜ğ’‚ğ’ğ’• ğ’•ğ’ ğ’–ğ’”ğ’† ğ‘«ğ‘­ğ‘º ğ’ğ’ğ’ğ’š (ğ’†ğ’—ğ’†ğ’ ğ’•ğ’‰ğ’ğ’–ğ’ˆğ’‰ ğ’•ğ’‰ğ’† ğ’ˆğ’“ğ’‚ğ’‘ğ’‰ ğ’‰ğ’‚ğ’” ğ’…ğ’Šğ’“ğ’†ğ’„ğ’•ğ’†ğ’… ğ’„ğ’šğ’„ğ’ğ’†ğ’”) ğ’•ğ’‰ğ’†ğ’ ğ’–ğ’”ğ’† ğ’•ğ’‰ğ’† ğ‘«ğ‘­ğ‘º 
//        ğ’ğ’†ğ’•ğ’‰ğ’ğ’… ğ’‚ğ’” ğ’–ğ’”ğ’†ğ’… ğ’Šğ’ "ğ‘·ğ’“ğ’ğ’ƒğ’ğ’†ğ’ - 1 (ğ‘©ğ’‚ğ’”ğ’†ğ’… ğ’ğ’ ğ‘»ğ’ğ’‘ğ’ğ’ğ’ğ’ˆğ’Šğ’„ğ’‚ğ’ ğ‘ºğ’ğ’“ğ’•).ğ’„ğ’‘ğ’‘" ğ’‡ğ’Šğ’ğ’†.

void dfsHelper(int src, map<int, bool> &visited, list<int> &res)
{
	visited[src]=true;

	// go to all the unvisited nodes of the current
    // node, but one by one
	for(auto nbr: mp[src])
	{
		if(!visited[nbr])
			dfsHelper(nbr, visited, res);
	}

	// in the last push the src in the FRONT of the list
	// to resolve all the dependencies
	res.push_front(src);
	return;
}

list<int> topoSort()
{
	map<int, bool> visited;

	// mark all the vertices as not visited 
	// in the beginning
	for(auto p: mp)
		visited[p.first]=false;

	// to store the topological ordering
	list<int> res;

	// dfs function is to be called for all vertices in 
	// directed graphs in order to include all vertices 
	// in the final topological ordering(see the graph below
	// to understand why?)
	for(auto p: mp)
	{
		int vertex=p.first;
		if(!visited[vertex])
			dfsHelper(vertex, visited, res);
	}

	// return the topological ordering at last
	return res;
}

/* Why the dfsHelper fâ¿ is needed to be called for ALL the vertices?
   â€¢ Because it will not include all the vertices in some directed graphs cases such as given below âŸ¶
     Following are the vertices in the graph: 0 ------> 2
     										  1 ------> 2
     										  1 ------> 4
     										  2 ------> 5
     										  4 ------> 5
*/

// Time Complexity: O(|V|+|E|)