/*Problem Statement: Find the minimum depth of a binary tree. 
                     ğ‘»ğ’‰ğ’† ğ’ğ’Šğ’ğ’Šğ’ğ’–ğ’ ğ’…ğ’†ğ’‘ğ’•ğ’‰ ğ’Šğ’” ğ’•ğ’‰ğ’† ğ’ğ’–ğ’ğ’ƒğ’†ğ’“ ğ’ğ’‡ ğ’ğ’ğ’…ğ’†ğ’” ğ’‚ğ’ğ’ğ’ğ’ˆ ğ’•ğ’‰ğ’† ğ’”ğ’‰ğ’ğ’“ğ’•ğ’†ğ’”ğ’• ğ’‘ğ’‚ğ’•ğ’‰ ğ’‡ğ’“ğ’ğ’ ğ’•ğ’‰ğ’† ğ’“ğ’ğ’ğ’• 
                     ğ’ğ’ğ’…ğ’† ğ’•ğ’ ğ’•ğ’‰ğ’† ğ’ğ’†ğ’‚ğ’“ğ’†ğ’”ğ’• ğ’ğ’†ğ’‚ğ’‡ ğ’ğ’ğ’…ğ’†.
*/

/*
 * Definition for a binary tree node.
 * struct node {
 *     int val;
 *     node *left;
 *     node *right;
 *     node() : val(0), left(nullptr), right(nullptr) {}
 *     node(int x) : val(x), left(nullptr), right(nullptr) {}
 *     node(int x, node *left, node *right) : val(x), left(left), right(right) {}
 * };
*/

/*UNDERLYING CONCEPT --------->
  # This problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. 
  # The only difference will be, instead of keeping track of all the nodes in a level, we will only track 
    the depth of the tree. 
  # As soon as we find our first leaf node, that level will represent the minimum depth of the tree.
*/

long long minDepthOfBT(node *root)
{
	if(root==nullptr)
	   return 0;
    
    //to store the minDepth
	long long minDepth=0;

	queue<node *> q;
	q.push(root);

	while(!q.empty())
	{
	   minDepth++; //increase minDepth by 1
	   long long levelSize=q.size();

	   for(long long i=0; i<levelSize; i++)
	   {
	      node *t=q.front();
	      q.pop();
          
          //check if this is a leaf node or not
	      if(t->left==nullptr && t->right==nullptr)
	         return minDepth;
          
          //insert the children of the popped out node in the queue
	      if(t->left!=nullptr)
	         q.push(t->left);

	      if(t->right!=nullptr)
	         q.push(t->right);
	   }
	}

	return minDepth;
}


/* # Time complexity: O(n), where â€˜nâ€™ is the total number of nodes in the tree. 
                      This is due to the fact that we traverse each node once.
   # Space complexity: O(n) as we need O(n) space for the queue. 
                       âˆµ ğ’˜ğ’† ğ’„ğ’‚ğ’ ğ’‰ğ’‚ğ’—ğ’† ğ’‚ ğ’ğ’‚ğ’™ğ’Šğ’ğ’–ğ’ ğ’ğ’‡ (ğ’/2) ğ’ğ’ğ’…ğ’†ğ’” ğ’‚ğ’• ğ’‚ğ’ğ’š ğ’ğ’†ğ’—ğ’†ğ’ (ğ’•ğ’‰ğ’Šğ’” ğ’„ğ’ğ’–ğ’ğ’… ğ’‰ğ’‚ğ’‘ğ’‘ğ’†ğ’ ğ’ğ’ğ’ğ’š ğ’‚ğ’• ğ’•ğ’‰ğ’† 
                       ğ’ğ’ğ’˜ğ’†ğ’”ğ’• ğ’ğ’†ğ’—ğ’†ğ’), ğ’•ğ’‰ğ’†ğ’“ğ’†ğ’‡ğ’ğ’“ğ’† ğ’˜ğ’† ğ’˜ğ’Šğ’ğ’ ğ’ğ’†ğ’†ğ’… ğ‘¶(ğ’) ğ’”ğ’‘ğ’‚ğ’„ğ’† ğ’•ğ’ ğ’”ğ’•ğ’ğ’“ğ’† ğ’•ğ’‰ğ’†ğ’ ğ’Šğ’ ğ’•ğ’‰ğ’† ğ’’ğ’–ğ’†ğ’–ğ’†.
*/