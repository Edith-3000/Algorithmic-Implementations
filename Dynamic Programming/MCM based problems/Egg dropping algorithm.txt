/*PROBLEM: There are n number of eggs and a building which has k floors. 
           Write an algorithm to find the minimum number of drops required to find the 
           critical or threshold floor.
           Critical/Threshold floor -> The highest floor from which if the egg is dropped
                                       it won't break.

Note: # One trial is â€“> dropping an egg once from the particular floor.
      # If egg does not break after dropping, will be used again.
      # If egg breaks when dropped from some floor then it will break if dropped from any 
        higher floor.
      # If egg does not break when dropped from some floor then it will not break if dropped
        from any lower floor.
*/

/*Few Important points regarding this algorithm â‡’
  â— Egg dropping refers to a class of problems in which it is important to find the correct 
    response without exceeding a (low) number of certain failure states. 

  â— In a toy example, there is a tower of n floors, and an egg dropper with k ideal eggs. The 
    physical  properties of the ideal egg is such that it will not shatter if it is dropped from 
    floor n* or below and will get completely damaged  if it is dropped from floor (n* + 1)
    or above.

  â— The problem is to find a strategy such that the egg dropper can determine the floor 
    n*(critical or threshold floor) in as few egg drops as possible. 

  â— This problem has many applications in the real world such as avoiding a call out to the 
    slow HDD, or attempting to minimize cache misses, or running a large number of expensive 
    queries on a database.
*/

/* â— So basically: For the ð™¬ð™¤ð™§ð™¨ð™© ð™˜ð™–ð™¨ð™š, using the ð™—ð™šð™¨ð™© ð™©ð™šð™˜ð™ð™£ð™žð™¦ð™ªð™š we have to ð™¢ð™žð™£ð™žð™¢ð™žð™¨ð™š ð™©ð™ð™š ð™©ð™¤ð™©ð™–ð™¡ 
                #ð™–ð™©ð™©ð™šð™¢ð™¥ð™©ð™¨ to find the ð™˜ð™§ð™žð™©ð™žð™˜ð™–ð™¡/ð™©ð™ð™§ð™šð™¨ð™ð™¤ð™¡ð™™ ð™›ð™¡ð™¤ð™¤ð™§.
   â— The solution is to try dropping an egg from every floor(from 1 to k) and recursively 
     calculate the minimum number of droppings needed in the worst case. The floor which gives
     the minimum value in the ð™¬ð™¤ð™§ð™¨ð™© ð™˜ð™–ð™¨ð™š is going to be part of the solution.
   â— Meaning of a ð™¬ð™¤ð™§ð™¨ð™©-ð™˜ð™–ð™¨ð™š ð™¨ð™˜ð™šð™£ð™–ð™§ð™žð™¤: ð™¬ð™¤ð™§ð™¨ð™©-ð™˜ð™–ð™¨ð™š ð™¨ð™˜ð™šð™£ð™–ð™§ð™žð™¤ gives the user the ð™¨ð™ªð™§ð™šð™©ð™® of the 
     threshold floor. For example- If we have â€˜1â€™ egg and â€˜kâ€™ floors, we will start dropping 
     the egg from the first floor till the egg breaks suppose on the â€˜kthâ€™ floor so the number 
     of tries to give us ð™¨ð™ªð™§ð™šð™©ð™® is â€˜kâ€™.
   â— Another example for ð™¬ð™¤ð™§ð™¨ð™©-ð™˜ð™–ð™¨ð™š ð™¨ð™˜ð™šð™£ð™–ð™§ð™žð™¤ ----->
     Let there be â€˜2â€™ eggs and â€˜2â€™ floors then-:

     If we try throwing from â€˜1stâ€™ floor:
      # Number of tries in worst case= 1+max(0, 1)
      # 0 => If the egg breaks from first floor then it is threshold floor (best case possibility).
      # 1 => If the egg does not break from first floor we will now have â€˜2â€™ eggs and 1 floor to 
        test which will give answer as â€˜1â€™ (worst case possibility)
      # We take the worst case possibility in account, so 1+max(0, 1)=2

     If we try throwing from â€˜2ndâ€™ floor:
      # Number of tries in worst case= 1+max(1, 0)
      # 1 => If the egg breaks from second floor then we will have 1 egg and 1 floor to find 
        threshold floor.(Worst Case)
      # 0 => If egg does not break from second floor then it is threshold floor.(Best Case)
      # We take worst case possibility for surety, so 1+max(1, 0)=2.

     Now, The final answer is min(1st, 2nd, 3rdâ€¦.., kth floor)
     So answer here(for f=2) is â€˜2â€™.
*/

//RECURSIVE IMPLEMENTATION

long long eggDropRecur(long long f, long long e)
{
	//base condition(s)
	//if floors = 0 then no drops are required OR 
	//floors = 1 then 1 drop is required
	if(f==0 || f==1)
	   return f;
	//if only one egg is there then min #drops = #floors
	if(e==1)
	   return f;
    
    //initialising result
    long long res=LLONG_MAX;

	//choice diagram code
    /*check dropping from all the floors 1 to f and pick 
      the minimum among those.
      for every drop there are 2 scenarios - 
      a) either egg will break b) or egg will not break
    */
    //k for loop scheme
    for(long long k=1; k<=f; k++)
    {
       //calculating temporary_answer
       //for the worst case pick the maximum among a) and b)
       long long temp= 1 + max(eggDropRecur(k-1, e-1), 
                               eggDropRecur(f-k, e));

       //calculation of res from temporary_answers
       if(temp<res)
          res=temp;
    }

    //return final result
    return res;
}

//Time Complexity: O(2á¶ ) i.e. exponential
//Auxiliary Space :O(1) âˆµ There was no use of any data structure for storing values.
                          Although recursion uses stack internally.
//in the above algorithm #floors given in problem(n) are taken as (f),
                         #eggs given in problem(k) are taken as (e).

**********************************************************************************************************

//MEMOIZED IMPLEMENTATION

long long eggDropMemo(long long f, long long e)
{
	//base condition(s)
	//if floors = 0 then no drops are required OR 
	//floors = 1 then 1 drop is required
	if(f==0 || f==1)
	   return f;
	//if only one egg is there then min #drops = #floors
	if(e==1)
	   return f;
    
    //check if already calculated or not
    if(dp[i][j]!=-1) return dp[i][j];
    
    //initialising result
    long long res=LLONG_MAX;

	//choice diagram code
    /*check dropping from all the floors 1 to f and pick 
      the minimum among those.
      for every drop there are 2 scenarios - 
      a) either egg will break b) or egg will not break
    */
    //k for loop scheme
    for(long long k=1; k<=f; k++)
    {
       //calculating temporary_answer
       //for the worst case pick the maximum among a) and b)
       long long temp= 1 + max(eggDropMemo(k-1, e-1), 
                               eggDropMemo(f-k, e));

       //calculation of res from temporary_answers
       if(temp<res)
          res=temp;
    }

    //return final result
    return dp[i][j]=res;
}

/*dp[][] is a 2 D global matrix/vector of vectors, with size (f+1)*(e+1) 
  and initialized with -1, memset(dp, -1, sizeof(dp));
*/
//Time Complexity: 
//Auxiliary Space :O(f*e) 
//in the above algorithm #floors given in problem(n) are taken as (f),
                         #eggs given in problem(k) are taken as (e).

**********************************************************************************************************

//OPTIMIZED MEMOIZED IMPLEMENTATION

long long eggDropMemoOptimized(long long f, long long e)
{
	//base condition(s)
	//if floors = 0 then no drops are required OR 
	//floors = 1 then 1 drop is required
	if(f==0 || f==1)
	   return f;
	//if only one egg is there then min #drops = #floors
	if(e==1)
	   return f;
    
    //check if already calculated or not
    if(dp[i][j]!=-1) return dp[i][j];
    
    //initialising result
    long long res=LLONG_MAX;

	//choice diagram code
    /*check dropping from all the floors 1 to f and pick 
      the minimum among those.
      for every drop there are 2 scenarios - 
      a) either egg will break b) or egg will not break
    */
    //k for loop scheme
    for(long long k=1; k<=f; k++)
    {
       //calculating temporary_answer
       //for the worst case pick the maximum among a) and b)
       long long left, right;

       if(dp[k-1][e-1]!=-1)
          left=dp[k-1][e-1];
       else
       {
          dp[k-1][e-1]= eggDropMemoOptimized(k-1, e-1);
          left= dp[k-1][e-1];
       }

       if(dp[f-k][e]!=-1)
          right=dp[k-1][e-1];
       else
       {
          dp[k-1][e-1]= eggDropMemoOptimized(f-k, e);
          right= dp[k-1][e-1];
       }

       long long temp= 1 + max(left, right);

       //calculation of res from temporary_answers
       if(temp<res)
          res=temp;
    }

    //return final result
    return dp[i][j]=res;
}

/*dp[][] is a 2 D global matrix/vector of vectors, with size (f+1)*(e+1) 
  and initialized with -1, memset(dp, -1, sizeof(dp));
*/
//Time Complexity: 
//Auxiliary Space :O(f*e) 
//in the above algorithm #floors given in problem(n) are taken as (f),
                         #eggs given in problem(k) are taken as (e).

**********************************************************************************************************

//TABULATION IMPLEMENTATION

long long eggDropTabu(long long f, long long e)
{
	//initialisation of dp matrix
	//if floors = 0 then no drops are required OR 
	//floors = 1 then 1 drop is required
	for(long long i=0; i<=1; i++)
	{
	   for(long long j=0; j<=e; j++)
	      dp[i][j]=i;
	}
	//if only one egg is there then min #drops = #floors
	for(long long i=2; i<=f; i++)
	   dp[i][1]=i;

	//choice diagram code iterative version
	//here i represents #floors, j represents #eggs taken in consideration
	for(long long i=2; i<=(f-1); i++)
	{
	   for(long long j=2; j<=(e-1); j++)
	   {
	      //initialising result 
	      dp[i][j]=LLONG_MAX;

	      //"k loop scheme for corresponding i & j"
	      for(long long k=1; k<=i; k++)
	      {
             long long temp= 1 + max(dp[k-1][j-1], dp[i-k][j]);
             if(temp<dp[i][j])
                dp[i][j]=temp;
	      }
	   }
	}

	//return final result
	return dp[f][e];
}

//dp[][] is a 2 D global matrix/vector of vectors, with size (f+1)*(e+1) 
/*Time Complexity: O(f*eÂ²), Where â€˜fâ€™ is the #floors and â€˜eâ€™ is the #eggs 
  Auxiliary Space: O(n*k),  âˆµ a 2-D array of size â€˜(f+1)*(e+1)â€™ is used for 
                              storing elements.
*/