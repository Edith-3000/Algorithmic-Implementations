/*PROBLEM: Given a binary tree, find the maximum path sum. The path may start and end at any 
           node in the tree.
           NOTE: The value of a node can be any integer.
*/

/* Definition for a binary tree node ⟶
   struct node {
       int val;
       node *left;
       node *right;
       node() : val(0), left(nullptr), right(nullptr) {}
       node(int x) : val(x), left(nullptr), right(nullptr) {}
       node(int x, node *left, node *right) : val(x), left(left), right(right) {}
   };
*/

long long maxPathSumBwAnyTwoNodes(node *root, long long &res)
{
	//base condition
	if(root==nullptr)
	   return 0;

	//hypothesis
	long long l= maxPathSumBwAnyTwoNodes(root->left, res);
	long long r= maxPathSumBwAnyTwoNodes(root->right, res);

	//induction
	long long temp=max(max(l, r)+root->val, root->val); //taken in consideration the case 
	                                                   //when l & r both can be -ve
	long long ans=max(temp, l+r+root->val);
    res=max(res, ans);

    return temp;
}

/* # The final answer is stored in res variable, which is passed by reference in every fⁿ call.
     In the main() fⁿ res is initialised as res= LLONG_MIN;
   # Time Complexity: O(n), since we must visit each node, where n are the #nodes in binary tree.
   # Auxiliary Space Complexity: O(1)
   # Space complexity of the internal call stack: O(h), where h is the height of the binary tree,
                                                  h may be O(log(n)), if a balanced tree or
                                                  h maye be O(n), otherwise.
*/